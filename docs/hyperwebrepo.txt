Directory Structure:

└── ./
    ├── __tests__
    │   ├── ammContract.test.ts
    │   ├── setup.test.ts
    │   └── simpleState.test.ts
    ├── dist
    │   └── contracts
    │       ├── ammContract.js
    │       └── simpleState.js
    ├── docs
    │   └── WRITING_FIRST_CONTRACT.md
    ├── scripts
    │   └── build.ts
    ├── src
    │   ├── amm-contract
    │   │   ├── amm.ts
    │   │   ├── index.ts
    │   │   ├── sdk.ts
    │   │   └── types.ts
    │   └── simple-state
    │       └── index.ts
    ├── test-utils
    │   └── sleep.ts
    ├── jest.config.js
    └── README.md



---
File: /__tests__/ammContract.test.ts
---

// @ts-nocheck
import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { assertIsDeliverTxSuccess } from '@cosmjs/stargate';

import path from "path";
import fs from 'fs';
import { getSigningJsdClient, jsd } from 'hyperwebjs'
import { useChain, generateMnemonic } from 'starshipjs';
import { sleep } from '../test-utils/sleep';
import './setup.test';

describe('Contract 2: AMM contract test', () => {
  let wallet, denom, address, queryClient, signingClient;
  let chainInfo, getCoin, getRpcEndpoint, creditFromFaucet;
  let contractCode, contractIndex;

  let wallet2, address2;
  let fee;

  const denom2 = "uhypweb", uatom = "uatom", uusdc = "uusdc";

  beforeAll(async () => {
    ({
      chainInfo,
      getCoin,
      getRpcEndpoint,
      creditFromFaucet
    } = useChain('hyperweb'));
    denom = (await getCoin()).base;

    // Initialize wallet
    wallet = await DirectSecp256k1HdWallet.fromMnemonic(generateMnemonic(), {
      prefix: chainInfo.chain.bech32_prefix
    });
    address = (await wallet.getAccounts())[0].address;
    console.log(`contract creator address for amm: ${address}`)

    // Initialize wallet2
    wallet2 = await DirectSecp256k1HdWallet.fromMnemonic(generateMnemonic(), {
      prefix: chainInfo.chain.bech32_prefix
    });
    address2 = (await wallet2.getAccounts())[0].address;
    console.log(`contract creator address2 for amm: ${address2}`)

    // Create custom cosmos interchain client
    queryClient = await jsd.ClientFactory.createRPCQueryClient({
      rpcEndpoint: await getRpcEndpoint()
    });

    signingClient = await getSigningJsdClient({
      rpcEndpoint: await getRpcEndpoint(),
      signer: wallet
    });

    await creditFromFaucet(address, denom);
    await creditFromFaucet(address, denom2);
    await creditFromFaucet(address, uatom);
    await creditFromFaucet(address, uusdc);

    await creditFromFaucet(address2, denom);
    await creditFromFaucet(address2, denom2);

    fee = {amount: [{denom, amount: '100000'}], gas: '550000'};

    await sleep(2000); // sleep for 1 sec to get tokens transferred from faucet successfully
  });

  it('check balance', async () => {
    const balance = await signingClient.getBalance(address, denom);
    expect(balance.amount).toEqual("10000000000");
    expect(balance.denom).toEqual(denom);
  });

  it('instantiate contract', async () => {
    // Read contract code from external file
    const contractPath = path.join(__dirname, '../dist/contracts/ammContract.js');
    contractCode = fs.readFileSync(contractPath, 'utf8');

    const msg = jsd.jsd.MessageComposer.fromPartial.instantiate({
      creator: address,
      code: contractCode,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    // Parse the response to get the contract index
    const response = jsd.jsd.MsgInstantiateResponse.fromProtoMsg(result.msgResponses[0]);
    contractIndex = response.index;
    expect(contractIndex).toBeGreaterThan(0);
    console.log(`contract index: ${contractIndex}`);
  });

  it('query for contract based on index', async () => {
    const response = await queryClient.jsd.jsd.contracts({index: contractIndex});
    expect(response.contracts.code).toEqual(contractCode);
    expect(response.contracts.index).toEqual(contractIndex);
    expect(response.contracts.creator).toEqual(address);
  });

  it('perform getTotalSupply eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "getTotalSupply",
      arg: `{}`,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("0");
  });

  it('perform addLiquidity eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "addLiquidity",
      arg: `{"amount0":50000000, "amount1":50000000}`,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("null");
  });

  it('check balance after addLiquidity', async () => {
    const usdcBalance = await signingClient.getBalance(address, uusdc);
    expect(usdcBalance.amount).toEqual("9950000000");

    const atomBalance = await signingClient.getBalance(address, uatom);
    expect(atomBalance.amount).toEqual("9950000000");
  });

  it('perform swap eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "swap",
      arg: `{"tokenIn":"${uusdc}","amountIn":10000000}`,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("9969998.011982398");
  });
});



---
File: /__tests__/setup.test.ts
---

// @ts-nocheck
import path from 'path';

import { StargateClient } from '@cosmjs/stargate';

import { ConfigContext, useChain, useRegistry } from 'starshipjs';

beforeAll(async () => {
  const configFile = path.join(__dirname, '..', 'configs', 'local.yaml');
  ConfigContext.setConfigFile(configFile);
  ConfigContext.setRegistry(await useRegistry(configFile));
});

describe('Test clients', () => {
  let client;

  beforeAll(async () => {
    const { getRpcEndpoint } = useChain('hyperweb');
    client = await StargateClient.connect(await getRpcEndpoint());
  });

  it('check chain height', async () => {
    const height = await client.getHeight();

    expect(height).toBeGreaterThan(0);
  });
});



---
File: /__tests__/simpleState.test.ts
---

// @ts-nocheck
import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
import { assertIsDeliverTxSuccess } from '@cosmjs/stargate';

import path from "path";
import fs from 'fs';
import { getSigningJsdClient, jsd } from 'hyperwebjs'
import { useChain, generateMnemonic } from 'starshipjs';
import { sleep } from '../test-utils/sleep';
import './setup.test';

describe('JSD tests', () => {
  let wallet, denom, address, queryClient, signingClient;
  let chainInfo, getCoin, getRpcEndpoint, creditFromFaucet;
  let contractCode, contractIndex;

  let fee;

  beforeAll(async () => {
    ({
      chainInfo,
      getCoin,
      getRpcEndpoint,
      creditFromFaucet
    } = useChain('hyperweb'));
    denom = (await getCoin()).base;

    // Initialize wallet
    wallet = await DirectSecp256k1HdWallet.fromMnemonic(generateMnemonic(), {
      prefix: chainInfo.chain.bech32_prefix
    });
    address = (await wallet.getAccounts())[0].address;
    console.log(`contract creator address: ${address}`)

    // Create custom cosmos interchain client
    queryClient = await jsd.ClientFactory.createRPCQueryClient({
      rpcEndpoint: await getRpcEndpoint()
    });

    signingClient = await getSigningJsdClient({
      rpcEndpoint: await getRpcEndpoint(),
      signer: wallet
    });

    // set default fee
    fee = {amount: [{denom, amount: '100000'}], gas: '550000'};

    await creditFromFaucet(address);
    await sleep(2000); // sleep for 1 sec to get tokens transferred from faucet successfully
  });

  it('check balance', async () => {
    const balance = await signingClient.getBalance(address, denom);
    expect(balance.amount).toEqual("10000000000");
    expect(balance.denom).toEqual(denom);
  });

  it('instantiate contract', async () => {
    // Read contract code from external file
    const contractPath = path.join(__dirname, '../dist/contracts/simpleState.js');
    contractCode = fs.readFileSync(contractPath, 'utf8');

    const msg = jsd.jsd.MessageComposer.fromPartial.instantiate({
      creator: address,
      code: contractCode,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    // Parse the response to get the contract index
    const response = jsd.jsd.MsgInstantiateResponse.fromProtoMsg(result.msgResponses[0]);
    contractIndex = response.index;
    expect(contractIndex).toBeGreaterThan(0);
    console.log(`contract index: ${contractIndex}`);
  });

  it('query for contract based on index', async () => {
    const response = await queryClient.jsd.jsd.contracts({index: contractIndex});
    expect(response.contracts.code).toEqual(contractCode);
    expect(response.contracts.index).toEqual(contractIndex);
    expect(response.contracts.creator).toEqual(address);
  });

  it('query state before eval', async () => {
    const state = await queryClient.jsd.jsd.localState({index: contractIndex, key: "value"});
    expect(state).toEqual({value: ""});
  });

  it('perform inc eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "inc",
      arg: `{"x": 10}`,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("10");
  });

  it('eval read from eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "read",
      arg: "",
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("10");
  });

  it('query state after eval', async () => {
    const state = await queryClient.jsd.jsd.localState({index: contractIndex, key: "value"});
    expect(state).toEqual({value: "10"});
  });

  it('perform dec eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "dec",
      arg: `{"x": 5}`,
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("5");
  });

  it('eval read from eval', async () => {
    const msg = jsd.jsd.MessageComposer.fromPartial.eval({
      creator: address,
      index: contractIndex,
      fnName: "read",
      arg: "",
    });

    const result = await signingClient.signAndBroadcast(address, [msg], fee);
    assertIsDeliverTxSuccess(result);

    const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
    expect(response.result).toEqual("5");
  });
});



---
File: /dist/contracts/ammContract.js
---

// src/amm-contract/sdk.ts
function useStore(key, defaultValue) {
  return (state) => [
    () => state.get(key) ?? defaultValue,
    (value) => state.set(key, value)
  ];
}
function useMapping(keys, defaultValue) {
  return (state) => [
    (...args) => {
      const interleavedKey = [keys[0]];
      const pathKeys = keys.slice(1);
      for (let i = 0; i < pathKeys.length; i++) {
        interleavedKey.push(pathKeys[i], args[i]);
      }
      return state.get(interleavedKey.join("/")) ?? defaultValue;
    },
    (...args) => {
      const interleavedKey = [keys[0]];
      const pathKeys = keys.slice(1);
      const keyArgs = args.slice(0, -1);
      for (let i = 0; i < pathKeys.length; i++) {
        interleavedKey.push(pathKeys[i], keyArgs[i]);
      }
      state.set(interleavedKey.join("/"), args[args.length - 1]);
    }
  ];
}

// src/amm-contract/amm.ts
import { getBalance, sendCoins } from "~bank";
var totalSupply = useStore("totalSupply", 0);
var balance = useMapping(["balance", "address"], 0);
var reserves = useStore("reserves", [0, 0]);
var Contract = class {
  msg;
  address;
  totalSupply;
  setTotalSupply;
  balance;
  setBalance;
  reserves;
  setReserves;
  constructor(state, { msg, address }) {
    this.msg = msg;
    this.address = address;
    [this.totalSupply, this.setTotalSupply] = totalSupply(state);
    [this.balance, this.setBalance] = balance(state);
    [this.reserves, this.setReserves] = reserves(state);
  }
  token0 = "uusdc";
  // ibc denom for usdc
  token1 = "uatom";
  // ibc denom for atom
  getTotalSupply() {
    return this.totalSupply();
  }
  getBalance(address) {
    return this.balance(address);
  }
  getReserves() {
    return this.reserves();
  }
  #getBankBalance(address, token) {
    return getBalance(address, token);
  }
  #mint(to, amount) {
    const balance2 = this.balance(to);
    this.setBalance(to, balance2 + amount);
    this.setTotalSupply(this.totalSupply() + amount);
  }
  #burn(from, amount) {
    const balance2 = this.balance(from);
    if (balance2 < amount) {
      throw Error("insufficient balance");
    }
    this.setBalance(from, balance2 - amount);
    this.setTotalSupply(this.totalSupply() - amount);
  }
  #update(amount0, amount1) {
    const [reserve0, reserve1] = this.reserves();
    this.setReserves([
      reserve0 + amount0,
      reserve1 + amount1
    ]);
  }
  // swap method adjusted for uusdc and uatom scaling
  swap({ tokenIn, amountIn }) {
    const isToken0 = tokenIn == this.token0;
    const isToken1 = tokenIn == this.token1;
    if (!isToken0 && !isToken1) {
      throw Error("invalid token");
    }
    const [reserve0, reserve1] = this.reserves();
    let tokenOut, reserveIn, reserveOut;
    [tokenIn, tokenOut, reserveIn, reserveOut] = isToken0 ? [this.token0, this.token1, reserve0, reserve1] : [this.token1, this.token0, reserve1, reserve0];
    const adjustedAmountIn = amountIn / 1e6;
    sendCoins(this.msg.sender, this.address, {
      [tokenIn]: amountIn
      // Amount in uusdc/uatom remains unchanged
    });
    const amountInWithFee = adjustedAmountIn * 997 / 1e3;
    const amountOut = reserveOut * amountInWithFee / (reserveIn + amountInWithFee);
    sendCoins(this.address, this.msg.sender, {
      [tokenOut]: amountOut * 1e6
      // Convert output back to uusdc/uatom
    });
    this.#update(
      this.#getBankBalance(this.address, this.token0).amount,
      this.#getBankBalance(this.address, this.token1).amount
    );
    return amountOut * 1e6;
  }
  // addLiquidity method adjusted for uusdc and uatom scaling
  addLiquidity({ amount0, amount1 }) {
    sendCoins(this.msg.sender, this.address, {
      [this.token0]: amount0,
      // uusdc
      [this.token1]: amount1
      // uatom
    });
    const [reserve0, reserve1] = this.reserves();
    if (reserve0 > 0 || reserve1 > 0) {
      if (reserve0 * (amount1 / 1e6) != reserve1 * (amount0 / 1e6)) {
        throw Error("invalid liquidity");
      }
    }
    let shares = 0;
    const adjustedAmount0 = amount0 / 1e6;
    const adjustedAmount1 = amount1 / 1e6;
    if (this.totalSupply() > 0) {
      shares = Math.sqrt(adjustedAmount0 * adjustedAmount1);
    } else {
      shares = Math.min(
        adjustedAmount0 * this.totalSupply() / reserve0,
        adjustedAmount1 * this.totalSupply() / reserve1
      );
    }
    this.#mint(this.msg.sender, shares);
    this.#update(
      this.#getBankBalance(this.address, this.token0).amount,
      this.#getBankBalance(this.address, this.token1).amount
    );
    return shares;
  }
  // removeLiquidity method adjusted for uusdc and uatom scaling
  removeLiquidity({ shares }) {
    const bal0 = this.#getBankBalance(this.address, this.token0).amount;
    const bal1 = this.#getBankBalance(this.address, this.token1).amount;
    const totalSupply2 = this.totalSupply();
    const amount0 = bal0 * shares / totalSupply2 * 1e6;
    const amount1 = bal1 * shares / totalSupply2 * 1e6;
    this.#burn(this.msg.sender, shares);
    this.#update(bal0 - amount0 / 1e6, bal1 - amount1 / 1e6);
    sendCoins(this.address, this.msg.sender, {
      [this.token0]: amount0,
      // uusdc
      [this.token1]: amount1
      // uatom
    });
    return [amount0, amount1];
  }
};

// src/amm-contract/index.ts
var amm_contract_default = Contract;
export {
  Contract,
  amm_contract_default as default,
  useMapping,
  useStore
};
//# sourceMappingURL=ammContract.js.map



---
File: /dist/contracts/simpleState.js
---

// src/simple-state/index.ts
function reset(state) {
  const newValue = 0;
  state.set("value", newValue);
  return newValue;
}
function inc(state, { x }) {
  const oldValue = Number(state.get("value")) || 0;
  const newValue = oldValue + x;
  state.set("value", newValue);
  return newValue;
}
function dec(state, { x }) {
  const oldValue = Number(state.get("value")) || 0;
  const newValue = oldValue - x;
  state.set("value", newValue);
  return newValue;
}
function read(state) {
  return state.get("value");
}
export {
  dec,
  inc,
  read,
  reset
};
//# sourceMappingURL=simpleState.js.map



---
File: /docs/WRITING_FIRST_CONTRACT.md
---

# Writing Your First Contract

This guide walks you through creating a simple "Hello World" contract using Hyperweb. This contract will set an initial greeting message and provide a way to retrieve it.

## Prerequisites

Before starting, ensure you have:
- Set up the Hyperweb development environment (refer to the main [README](../README.md)).
- Basic understanding of TypeScript and object-oriented programming.

## Overview

Our "Hello World" contract will:

1. Set a greeting message when the contract is instantiated.
2. Provide a method to retrieve the message.

## Step 1: Create Your Contract Directory

1. Navigate to the `src/` directory.
2. Create a new folder named `hello-world`:

   ```bash
   mkdir src/hello-world
   ```

3. Inside the `hello-world` folder, create a file named `index.ts`:

   ```bash
   touch src/hello-world/index.ts
   ```

## Step 2: Implement the Hello World Contract

In `src/hello-world/index.ts`, define the contract as follows:

```ts
export interface State {
  get(key: string): string;
  set(key: string, value: any): void;
};

default export class HelloWorldContract {
    state: State;
    
    constructor(state: State) {
      this.state = state;
      this.state.set('greet', "Hello, World!"); // Set initial greeting in constructor
    }
    
    // Retrieve the greeting message
    greet(): string {
      return this.state.get('greet');
    }
}
```

### Explanation

- **Constructor**: Initializes the contract with the greeting message "Hello, World!".
- **`greet`**: Returns the message stored in the state.

## Step 3: Add the Contract to the Build Script

To include your contract in the build process:

1. Open `scripts/build.ts`.
2. Add an entry for the `hello-world` contract:

   ```ts
   const configs: BuildConfig[] = [
   // existing contracts
    {
      entryFile: 'src/hello-world',
      outFile: 'dist/contracts/helloWorld.js',
      externalPackages: []
    }
   ];
   ```

This configuration specifies the entry point and output file for the build process.

## Step 4: Build the Contract

Compile the contract:

```bash
yarn build
```

This will generate the bundled contract in `dist/contracts`, making it ready for deployment.

## Step 5: Write Tests for the Hello World Contract

Testing helps ensure the contract behaves as expected. In the `__tests__/` directory:

1. Create `helloWorld.test.ts`:

   ```bash
   touch __tests__/helloWorld.test.ts
   ```

2. Write test cases for greeting retrieval:

   ```js
   import { DirectSecp256k1HdWallet } from '@cosmjs/proto-signing';
   import { assertIsDeliverTxSuccess } from '@cosmjs/stargate';
   
   import path from "path";
   import fs from 'fs';
   import { getSigningJsdClient, jsd } from 'hyperwebjs';
   import { useChain, generateMnemonic } from 'starshipjs';
   import { sleep } from '../test-utils/sleep';
   import './setup.test';
   
   describe('Hello World Contract Tests', () => {
    let wallet, denom, address, queryClient, signingClient;
    let chainInfo, getCoin, getRpcEndpoint, creditFromFaucet;
    let contractCode, contractIndex;
   
    let fee;
   
    beforeAll(async () => {
    ({
      chainInfo,
      getCoin,
      getRpcEndpoint,
      creditFromFaucet
      } = useChain('hyperweb'));
       denom = (await getCoin()).base;
   
       // Initialize wallet
       wallet = await DirectSecp256k1HdWallet.fromMnemonic(generateMnemonic(), {
         prefix: chainInfo.chain.bech32_prefix
       });
       address = (await wallet.getAccounts())[0].address;
       console.log(`contract creator address: ${address}`);
   
       // Create custom cosmos interchain client
       queryClient = await jsd.ClientFactory.createRPCQueryClient({
         rpcEndpoint: await getRpcEndpoint()
       });
   
       signingClient = await getSigningJsdClient({
         rpcEndpoint: await getRpcEndpoint(),
         signer: wallet
       });
   
       // Set default fee
       fee = { amount: [{ denom, amount: '100000' }], gas: '550000' };
   
       await creditFromFaucet(address);
       await sleep(2000); // Wait for faucet transfer
    });
   
    it('check balance', async () => {
      const balance = await signingClient.getBalance(address, denom);
      expect(balance.amount).toEqual("10000000000");
      expect(balance.denom).toEqual(denom);
    });
   
    it('instantiate Hello World contract', async () => {
      // Read contract code from external file
      const contractPath = path.join(__dirname, '../dist/contracts/helloWorld.js');
      contractCode = fs.readFileSync(contractPath, 'utf8');
   
      const msg = jsd.jsd.MessageComposer.fromPartial.instantiate({
        creator: address,
        code: contractCode,
      });
   
      const result = await signingClient.signAndBroadcast(address, [msg], fee);
      assertIsDeliverTxSuccess(result);
   
      // Parse response to get the contract index
      const response = jsd.jsd.MsgInstantiateResponse.fromProtoMsg(result.msgResponses[0]);
      contractIndex = response.index;
      expect(contractIndex).toBeGreaterThan(0);
      console.log(`contract index: ${contractIndex}`);
    });
   
    it('query for initial greeting', async () => {
      const msg = jsd.jsd.MessageComposer.fromPartial.eval({
        creator: address,
        index: contractIndex,
        fnName: "greet",
        arg: "",
      });
   
      const result = await signingClient.signAndBroadcast(address, [msg], fee);
      assertIsDeliverTxSuccess(result);
   
      const response = jsd.jsd.MsgEvalResponse.fromProtoMsg(result.msgResponses[0]);
      expect(response.result).toEqual("Hello, World!");
    });
   });
   ```

3. Run the tests:

   ```bash
   yarn test
   ```

## Step 6: Deploy and Interact with the Contract

With the contract built and tested, you can now deploy it to the Hyperweb blockchain:

1. **Deploy**: Use Hyperweb’s deployment tools to deploy your contract.
2. **Interact**: Call the `greet` method to retrieve the greeting message from the deployed contract.

## Summary

You've successfully created, built, tested, and deployed a simple "Hello World" contract using Hyperweb.
This foundational contract will help as you move on to more complex contracts.
For further information, refer to the Hyperweb documentation.



---
File: /scripts/build.ts
---

import { HyperwebBuild, HyperwebBuildOptions } from '@hyperweb/build';
import { join } from 'path';

interface BuildConfig {
  entryFile: string;
  outFile: string;
  externalPackages: string[];
}

const configs: BuildConfig[] = [
  {
    entryFile: 'src/simple-state/index.ts',
    outFile: 'dist/contracts/simpleState.js',
    externalPackages: ['otherpackage', '~somepackage']
  },
  {
    entryFile: 'src/amm-contract/index.ts',
    outFile: 'dist/contracts/ammContract.js',
    externalPackages: ['~bank'],
  }
];

const rootDir = join(__dirname, '/../');

async function buildInterweb(config: BuildConfig): Promise<void> {
  const { entryFile, outFile, externalPackages } = config;

  const options: Partial<HyperwebBuildOptions> = {
    entryPoints: [join(rootDir, entryFile)],
    outfile: join(rootDir, outFile),
    external: externalPackages
  };

  try {
    await HyperwebBuild.build(options);
    console.log(`Build completed successfully! Output: ${options.outfile}`);
  } catch (error) {
    console.error('Build failed:', error);
    throw error;
  }
}

async function main() {
  for (const config of configs) {
    try {
      await buildInterweb(config);
    } catch (error) {
      console.error(`Build failed for ${config.entryFile}:`, error);
    }
  }
}

main().catch(console.error);


---
File: /src/amm-contract/amm.ts
---

// @ts-ignore, `~bank` is an internal package
import { getBalance, sendCoins } from '~bank';

import { useMapping, useStore } from './sdk';
import { MappingStore, Msg, State, Store } from './types'

const totalSupply: Store<number> = useStore('totalSupply', 0);
const balance: MappingStore<[string], number> = useMapping(['balance', 'address'], 0);
const reserves: Store<[number, number]> = useStore('reserves', [0, 0]);

export class Contract {
  msg: Msg;
  address: string;
  totalSupply;
  setTotalSupply;
  balance; 
  setBalance;
  reserves;
  setReserves;

  constructor(state: State, {msg, address}: {msg: Msg, address: string}) {
    this.msg = msg;
    this.address = address;

    [this.totalSupply, this.setTotalSupply] = totalSupply(state);
    [this.balance, this.setBalance] = balance(state);
    [this.reserves, this.setReserves] = reserves(state);
  }

  token0: string = "uusdc"; // ibc denom for usdc
  token1: string = "uatom"; // ibc denom for atom

  getTotalSupply(): number {
    return this.totalSupply();
  }

  getBalance(address: string): number {
    return this.balance(address);
  }

  getReserves(): [number, number] {
    return this.reserves();
  }

  #getBankBalance(address: string, token: string): { amount: number, denom: string } {
    return getBalance(address, token);
  }

  #mint(to: string, amount: number) {
    const balance = this.balance(to);
    this.setBalance(to, balance + amount);
    this.setTotalSupply(this.totalSupply() + amount);
  }

  #burn(from: string, amount: number) {
    const balance = this.balance(from);
    if (balance < amount) {
      throw Error("insufficient balance");
    }
    this.setBalance(from, balance - amount);
    this.setTotalSupply(this.totalSupply() - amount);
  }

  #update(amount0: number, amount1: number) {
    const [reserve0, reserve1] = this.reserves();
    this.setReserves([
      reserve0 + amount0,
      reserve1 + amount1,
    ]);
  }

  // swap method adjusted for uusdc and uatom scaling
  swap({tokenIn, amountIn}: {tokenIn: string, amountIn: number}) {
    const isToken0 = tokenIn == this.token0;
    const isToken1 = tokenIn == this.token1;

    if (!isToken0 && !isToken1) {
      throw Error("invalid token");
    }

    const [reserve0, reserve1] = this.reserves();
    let tokenOut, reserveIn, reserveOut;

    [tokenIn, tokenOut, reserveIn, reserveOut] =
      isToken0
        ? [this.token0, this.token1, reserve0, reserve1]
        : [this.token1, this.token0, reserve1, reserve0];

    // Adjust amountIn to account for scaling (from uusdc/uatom)
    const adjustedAmountIn = amountIn / 1e6;  // Convert back to full tokens
    sendCoins(this.msg.sender, this.address, {
      [tokenIn]: amountIn, // Amount in uusdc/uatom remains unchanged
    });

    const amountInWithFee = adjustedAmountIn * 997 / 1000;
    const amountOut = (reserveOut * amountInWithFee) / (reserveIn + amountInWithFee);

    sendCoins(this.address, this.msg.sender, {
      [tokenOut]: amountOut * 1e6,  // Convert output back to uusdc/uatom
    });

    this.#update(
      this.#getBankBalance(this.address, this.token0).amount,
      this.#getBankBalance(this.address, this.token1).amount,
    );

    return amountOut * 1e6;  // Return result in uusdc/uatom
  }

  // addLiquidity method adjusted for uusdc and uatom scaling
  addLiquidity({amount0, amount1}: {amount0: number, amount1: number}) {
    sendCoins(this.msg.sender, this.address, {
      [this.token0]: amount0, // uusdc
      [this.token1]: amount1, // uatom
    });

    const [reserve0, reserve1] = this.reserves();

    if (reserve0 > 0 || reserve1 > 0) {
      if (reserve0 * (amount1 / 1e6) != reserve1 * (amount0 / 1e6)) {
        throw Error("invalid liquidity");
      }
    }

    let shares = 0;
    const adjustedAmount0 = amount0 / 1e6;  // Convert to full tokens
    const adjustedAmount1 = amount1 / 1e6;  // Convert to full tokens

    if (this.totalSupply() > 0) {
      shares = Math.sqrt(adjustedAmount0 * adjustedAmount1);
    } else {
      shares = Math.min(
        (adjustedAmount0 * this.totalSupply()) / reserve0,
        (adjustedAmount1 * this.totalSupply()) / reserve1,
      );
    }

    this.#mint(this.msg.sender, shares);

    this.#update(
      this.#getBankBalance(this.address, this.token0).amount,
      this.#getBankBalance(this.address, this.token1).amount,
    );

    return shares;
  }

  // removeLiquidity method adjusted for uusdc and uatom scaling
  removeLiquidity({shares}: {shares: number}) {
    const bal0 = this.#getBankBalance(this.address, this.token0).amount;
    const bal1 = this.#getBankBalance(this.address, this.token1).amount;
    const totalSupply = this.totalSupply();

    // Adjust output to uusdc/uatom
    const amount0 = (bal0 * shares / totalSupply) * 1e6;
    const amount1 = (bal1 * shares / totalSupply) * 1e6;

    this.#burn(this.msg.sender, shares);
    this.#update(bal0 - amount0 / 1e6, bal1 - amount1 / 1e6);

    sendCoins(this.address, this.msg.sender, {
      [this.token0]: amount0,  // uusdc
      [this.token1]: amount1,  // uatom
    });

    return [amount0, amount1];  // Return uusdc/uatom
  }
}



---
File: /src/amm-contract/index.ts
---

export * from './amm'
export * from './sdk'
export * from './types'

import { Contract } from './amm'

export default Contract;  // need to explicitly export Contract to make it the entry point



---
File: /src/amm-contract/sdk.ts
---

import { MappingStore, State, Store } from "./types";

export function useStore<ValueType>(key: string, defaultValue: ValueType): Store<ValueType> {
  return (state: State) => [
    () => state.get(key) ?? defaultValue,
    (value: ValueType) => state.set(key, value)
  ]
}

export function useMapping<Params extends any[], ValueType>(keys: string[], defaultValue: ValueType): MappingStore<Params, ValueType> {
  return (state: State) => [
    (...args: Params) => {
      // assert: keys.length === args.length + 1
      const interleavedKey = [keys[0]];
      const pathKeys = keys.slice(1);
      for(let i = 0; i < pathKeys.length; i++) {
        interleavedKey.push(pathKeys[i], args[i]);
      }
      return state.get(interleavedKey.join('/')) ?? defaultValue;
    },
    (...args: [...Params, ValueType]) => {
      const interleavedKey = [keys[0]];
      const pathKeys = keys.slice(1);
      const keyArgs = args.slice(0, -1) as Params;
      for(let i = 0; i < pathKeys.length; i++) {
        interleavedKey.push(pathKeys[i], keyArgs[i]);
      }
      state.set(interleavedKey.join('/'), args[args.length - 1]);
    }
  ]
}



---
File: /src/amm-contract/types.ts
---

export interface State {
  get(key: string): string;
  set(key: string, value: any): void;
}

export interface Msg {
  sender: string;
  sent_funds: { [key: string]: number };
}

export type MappingStore<Params extends any[], ValueType> = (state: State) => [
  (...args: Params) => ValueType, 
  (...args: [...Params, ValueType]) => void,
]

export type Store<ValueType> = (state: State) => [
  () => ValueType,
  (value: ValueType) => void,
]



---
File: /src/simple-state/index.ts
---

export interface State {
  get(key: string): string;
  set(key: string, value: any): void;
}

export function reset(state: State) {
  const newValue = 0;
  state.set('value', newValue);
  return newValue
}
export function inc(state: State, { x }: { x: number }) {
  const oldValue = Number(state.get('value')) || 0;
  const newValue = oldValue + x;
  state.set('value', newValue);
  return newValue
}
export function dec(state: State, { x }: { x: number }) {
  const oldValue = Number(state.get('value')) || 0;
  const newValue = oldValue - x;
  state.set('value', newValue);
  return newValue
}

export function read(state: State) {
  return state.get('value');
}



---
File: /test-utils/sleep.ts
---

export function sleep(time: number) {
  return new Promise((resolve) => setTimeout(resolve, time));
}



---
File: /jest.config.js
---

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
    preset: "ts-jest",
    testEnvironment: "node",
    testTimeout: 150000,
    transform: {
        "^.+\\.tsx?$": [
            "ts-jest",
            {
                babelConfig: false,
                tsconfig: "tsconfig.json",
            },
        ],
    },
    transformIgnorePatterns: [`/node_modules/*`],
    testRegex: "(/__tests__/.*|(\\.|/)(test|spec))\\.(jsx?|tsx?)$",
    moduleFileExtensions: ["ts", "tsx", "js", "jsx", "json", "node"],
    modulePathIgnorePatterns: ["dist/*"]
};



---
File: /README.md
---

# hyperweb

<p align="center" width="100%">
    <img height="90" src="https://github.com/user-attachments/assets/f672f9b8-e59a-4f44-8f51-df3e8d2eaae5" />
</p>

<p align="center" width="100%">
  <a href="https://github.com/hyperweb-io/hyperweb-boilerplate/actions/workflows/e2e-tests.yaml">
    <img height="20" src="https://github.com/hyperweb-io/hyperweb-boilerplate/actions/workflows/e2e-tests.yaml/badge.svg" />
  </a>
  <br />
   <a href="https://github.com/hyperweb-io/hyperweb-boilerplate/blob/main/LICENSE"><img height="20" src="https://img.shields.io/badge/license-MIT-blue.svg"></a>
   <a href="https://github.com/cosmology-tech/starshipjs"><img height="20" src="https://img.shields.io/badge/CI-Starship-blue"></a>
</p>

# Hyperweb Boilerplate

Welcome to **Hyperweb**, the blockchain for JavaScript smart contracts. Hyperweb enables developers to write decentralized applications (dApps) using TypeScript, designed for cross-chain compatibility and ease of development.

## Table of Contents

- [Quickstart](#quickstart)
  - [Bundle Contracts](#bundle-contracts)
- [Infrastructure Setup](#infrastructure-setup)
  - [Option 1: Using Starship](#option-1-using-starship)
    - [Enable Kubernetes in Docker Desktop](#enable-kubernetes-in-docker-desktop)
    - [Install `kubectl` and `helm`](#install-kubectl-and-helm)
    - [Start Starship](#start-starship)
    - [Interact with the Chain](#interact-with-the-chain)
  - [Option 2: Using Docker](#option-2-using-docker)
    - [Run Hyperweb with Docker](#run-hyperweb-with-docker)
    - [Interact with Chain](#interact-with-chain)
- [Run Tests](#run-tests)
- [Usage](#usage)
  - [Creating JSD Client](#creating-jsd-client)
  - [Deploying and Interacting with the Contract](#deploying-and-interacting-with-the-contract)
  - [Instantiating a Contract](#instantiating-a-contract)
  - [Interacting with the Contract](#interacting-with-the-contract)
  - [Evaluating Functions on the Contract](#evaluating-functions-on-the-contract)
  - [Reading Contract State](#reading-contract-state)
- [Development](#development)

## Installation

1. Clone the repository:

```bash
git clone https://github.com/hyperweb-io/hyperweb-boilerplate.git

yarn
```

## Repository overview

* `src/`: Contains source code for each contract, with each sub-directory as a separate contract.
  * `simple-state`: A simple contract to demonstrate state transitions.
  * `amm-contract`: An automated market maker contract using the Bank module.
* `scripts/`: Holds the build script to create contract bundles.
* `__tests__/`: Includes test cases to validate contract functionality.
* `dist/`: Output folder for bundled contracts ready for deployment.

## Quickstart

### Bundle Contracts

1. Clean previous builds:
```bash
yarn clean
```
2. Build contracts:
```bash
yarn build
```

This bundles the contracts from src/** into dist/contracts/.

## Infrastructure Setup

### Option 1: Using Starship
[Starship](https://github.com/cosmology-tech/starship) is a Kubernetes-based blockchain orchestrator. It sets up a local blockchain environment with full cross-chain compatibility.

#### Enable Kubernetes in Docker Desktop
Docker Desktop includes a standalone Kubernetes server and client, as well as Docker CLI integration that runs on your machine.
To enable Kubernetes in Docker Desktop:

1. From the Docker Dashboard, select the Settings.
2. Select Kubernetes from the left sidebar.
3. Next to Enable Kubernetes, select the checkbox.
4. Select Apply & Restart to save the settings and then click Install to confirm.

#### Install `kubectl` and `helm`. 
```bash
yarn starship install  ## and follow steps to install kubectl and helm
```

#### Start Starship
```bash
yarn starship start
```
Spins up a local blockchain using configs/local.yaml.
Wait for Starship to initialize.

For more details, refer to the [Starship Docs](https://docs.cosmology.zone/starship/).

### Option 2: Using Docker
Alternatively, Hyperweb can be run using Docker, which simplifies setup and enables you to interact with the blockchain without requiring Kubernetes.

#### Run Hyperweb with Docker
To spin up the chain using Docker, the following scripts are available in the package.json:

* Run Docker container:
  ```bash
  yarn docker
  ```

* Stop and remove the container:
  ```bash
  yarn docker:stop
  ```

### Interact with chain

This will set up the same chain environment that Starship provides, allowing you to interact with the chain using the same endpoints:
* REST: http://localhost:1317
* RPC: http://localhost:26657
* Faucet: http://localhost:8000
* Exposer: http://localhost:8081
* Registry: http://localhost:8001

Once the chain is running, you can follow the same steps to interact with the chain and run tests as detailed below.

## Run Tests
Once the setup it complete, you can run tests to validate the contract functionality.
Run tests:
```bash
yarn test
```
The test suite deploys the contracts, interacts with them, and validates state transitions. The tests are located in `__tests__/`.

---

## Usage

### Creating JSD Client

Once the contract is bundled, you need to create a client using `hyperwebjs` to interact with the Hyperweb chain.

Example setup to create a `hyperwebjs` client:

```ts
import { getSigningJsdClient, jsd } from 'hyperwebjs';

async function setupClient() {
  const wallet = await DirectSecp256k1HdWallet.fromMnemonic("your-mnemonic");
  const rpcEndpoint = "your-rpc-endpoint";

  const signingClient = await getSigningJsdClient({
    rpcEndpoint,
    signer: wallet
  });

  return signingClient;
}
```

### Deploying and Interacting with the Contract

To deploy and instantiate the contract on the Hyperweb blockchain, read the bundled contract file and use the `hyperwebjs` client to broadcast it to the chain.

Example deployment process:

```ts
import fs from 'fs';
import path from 'path';

async function deployContract(signingClient, address) {
  const contractCode = fs.readFileSync(path.join(__dirname, '../dist/contracts/bundle1.js'), 'utf8');

  const msg = jsd.jsd.MessageComposer.fromPartial.instantiate({
    creator: address,
    code: contractCode,
  });

  const fee = { amount: [{ denom: 'token', amount: '100000' }], gas: '550000' };

  const result = await signingClient.signAndBroadcast(address, [msg], fee);
  console.log('Contract deployed:', result);
}
```

### Instantiating a Contract

To instantiate the contract, use the `instantiate` method of the `hyperwebjs` client. The contract index will be returned, which is used to interact with the contract.

```ts
const contractCode = fs.readFileSync('dist/contracts/bundle1.js', 'utf8');
const result = await signingClient.signAndBroadcast(address, [
  jsd.jsd.MessageComposer.fromPartial.instantiate({
    creator: address,
    code: contractCode,
  })
], fee);

const contractIndex = jsd.jsd.MsgInstantiateResponse.fromProtoMsg(result.msgResponses[0]).index;
console.log('Contract instantiated with index:', contractIndex);
```

### Interacting with the Contract

Once the contract is instantiated, you can invoke functions like `inc`, `dec`, or `read` to interact with it.

Example to increment a value:

```ts
const msg = jsd.jsd.MessageComposer.fromPartial.eval({
  creator: address,
  index: contractIndex,
  fnName: "inc",
  arg: JSON.stringify({ x: 10 }),
});

const result = await signingClient.signAndBroadcast(address, [msg], fee);
console.log('Increment result:', result);
```

### Evaluating Functions on the Contract

To evaluate functions like `inc`, `dec`, or any other function within the contract, you can use the `eval` message type.

Example to decrement a value:

```ts
const msg = jsd.jsd.MessageComposer.fromPartial.eval({
  creator: address,
  index: contractIndex,
  fnName: "dec",
  arg: JSON.stringify({ x: 5 }),
});

const result = await signingClient.signAndBroadcast(address, [msg], fee);
console.log('Decrement result:', result);
```

### Reading Contract State

You can query the state of the contract by using the `read` function.

Example to read the contract state:

```ts
const state = await queryClient.jsd.jsd.localState({ index: contractIndex, key: 'value' });
console.log('Contract state:', state);
```

---

## Development

For local development, you can run the tests provided in the `__tests__/` folder to validate contract functionality using `starshipjs` to simulate chain interactions.

